# -*- coding: utf-8 -*-
"""Untitled2.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1US2XvxarWgOH_NNWos5U5Au7axH5Pc8w
"""

# -*- coding: utf-8 -*-
"""QUEUE MODEL.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/14RQo_bHj2ZL3jPBgvDTrkmHazBY5TzIL
"""

import numpy as np
np.random.seed(10)

class SSQ():
    def __init__(self):
        
        self.interarrivals = list(np.abs(np.random.normal(loc=2, scale=1, size=100)))
        self.service_times = list(np.random.uniform(low=3,high=4, size=100))

        print(self.interarrivals)
        print(self.service_times)

        self.clock = 0.0

        self.next_arrival = self.interarrivals.pop(0)
        self.next_departure = float('inf')

        self.num_in_queue = 0
        self.times_of_arrivalqueue = []
        self.service_times_in_queue = []

        self.total_delay = 0.0
        self.num_of_delays = 0.0

        self.server_status = 0 # initially idle
        self.last_event_time = 0.0
        self.utilization = 0.0  

        self.expected_number_of_customers_in_queue = 0  #expected number of customer in queue

    def arrival(self):
        self.next_arrival = self.next_arrival + self.interarrivals.pop(0)

        if self.server_status == 0: #server idle
            self.server_status = 1
            delay = 0.0
            self.total_delay += delay
            self.num_of_delays += 1
            self.next_departure = self.clock + self.service_times.pop(0)

        else:
            self.num_in_queue += 1
            self.times_of_arrivalqueue.append(self.clock)
            self.service_times_in_queue.append(self.service_times.pop(0))


    def departure(self,choice):
        
        if self.num_in_queue == 0:
            self.server_status = 0
            next_departure = float('inf')
        else:
            self.num_in_queue -= 1
            if choice == 1 : 
              arrival = self.times_of_arrivalqueue.pop(0) # FIFO
              self.next_departure = self.clock + self.service_times_in_queue.pop(0)  # next departure shcedule
              #print("fifo")
            elif choice ==2 : 
               arrival = self.times_of_arrivalqueue.pop(-1) # LIFO
               self.next_departure = self.clock + self.service_times_in_queue.pop(-1)   # next departure shcedule
               #print("lifo")
            elif choice == 3: 
              min_index = self.service_times_in_queue.index(min(self.service_times_in_queue))  # FINDING THE MIN SERVICE TIME , EVENT INDEX
              arrival = self.times_of_arrivalqueue.pop(min_index) #SJF
              self.next_departure = self.clock + self.service_times_in_queue.pop(min_index)   # next departure shcedule
              #print("sjf")


            delay = self.clock-arrival
            self.total_delay += delay
            self.num_of_delays += 1
            
           
              
            

    def simulate_next_event(self,choice):
        last_event_clock = self.clock  #to store previous event's clock value
        
        self.clock = min(self.next_arrival, self.next_departure)
        self.last_event_time = self.clock

        curr_clock = self.clock # current clock vlaue 
        

        prev_number_in_queue = self.num_in_queue 
        perv_server_status = self.server_status
        #print("prev queue number",prev_number_in_queue)

        # calculating the q_A and b_t values
        self.expected_number_of_customers_in_queue += prev_number_in_queue * (curr_clock - last_event_clock) 

        self.utilization += perv_server_status * (curr_clock - last_event_clock)


        if self.next_arrival<=self.next_departure:
            
            
           
            self.arrival()
            
            

            print("arrival at -> " + str(self.clock))
            print("Number of custer in queue in arrival", self.num_in_queue)
            print("Current clock", curr_clock)
            print("last cloock: ", self.last_event_time)
            
        
        else:
            
            curr_clock = self.next_departure
            
            self.departure(choice)
            """self.expected_number_of_customers_in_queue += prev_number_in_queue * (curr_clock - last_event_clock)
            self.utilization += perv_server_status * (curr_clock - last_event_clock)"""
            print("departure at -> " + str(self.clock))
            
        
        print("Server status: ", self.server_status)
        print("Number of customer in queue: ", self.num_in_queue)
        print("Times of arrival in the queue: ", self.times_of_arrivalqueue)
        print("Service times in the queue: ", self.service_times_in_queue)
        print("Total delay: ", self.total_delay)
        print("Next arrival : ", self.next_arrival)
        print("Next departure: ", self.next_departure)
        
        
        


    def start(self):
        print("Queue choice: \n1.FIFO \n2.LIFO \n3.SJF")
        choice = int(input("Enter queue choice: "))


        
        customer_served = 50


        while self.num_of_delays < customer_served: # until customer served 
                       
            self.simulate_next_event(choice)
            print("")

        if choice == 1 : print("FIFO")
        elif choice ==2 : print("LIFO")
        elif choice == 3 : print("SJF") 
        print("Average Delay: ", self.total_delay / self.num_of_delays )  # calculating the average delay
        
        print("Expected number of customers in queue: ", self.expected_number_of_customers_in_queue / self.clock)
        
        print("Utilization of server: ",self.utilization /self.clock )
        
       

        

s = SSQ()

s.start()